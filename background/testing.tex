\chapter{Kiến thức nền tảng}
\section{Kiểm thử bảo mật phần mềm bằng phương pháp fuzzing}
\textbf{Fuzzing} \parencite{klees2018evaluating} là một trong những phương pháp phổ biến nhất trong lĩnh vực kiểm thử bảo mật phần mềm nói chung và ứng dụng web nói riêng. Khái niệm fuzzing theo Bekrar, Bekrar, Groz và Mounier \parencite{vimpari2015evaluation} có nghĩa là đưa những dữ liệu đầu vào ngẫu nhiên hoặc không hợp lệ vào phần mềm để gây ra những hành vi bất thường, và xác định các lỗi cũng như khả năng tồn tại lỗ hổng bảo mật trong phần mềm. Mục đích của quan trọng nhất của fuzzing là gây lỗi hoặc làm sập (crash) hệ thống, mỗi một lỗi xuất hiện hoặc một lần hệ thống bị sập trong quá trình kiểm thủ là một dấu hiệu có lỗ hổng bảo mật tiềm ẩn. Sau đó những kĩ sư bảo mật sẽ phân tích các lỗi đó để tìm ra lý do và khai thác sâu hơn hoặc báo cáo lại với nhà cung cấp phần mềm (vendor) để vá lỗi.\par
Phương pháp fuzzing hữu dụng và phù hợp với việc kiểm thử hộp đen một phần vì tính tự động hóa cao của nó. Những mục tiêu kiểm thử trên phần mềm có thể là mọi ``giao diện'' có khả năng tương tác và nhận dữ liệu đầu vào từ người dùng. Mục tiêu kiểm thử của một phần mềm thường là những biến môi trường, nội dung và tên của những tập tin đang được sử dụng bởi phần mềm, những trường nhập dữ liệu, giao thức mà phần mềm dùng để giao tiếp với người dùng hoặc các phần mềm khác và các giao diện lập trình ứng dụng (application programming interface - API) được định nghĩa bởi phần mềm đó. Quá trình sinh ra trường hợp kiểm thử (testcase) cho các mục tiêu đó có thể được định nghĩa trước thành một danh sách, hoặc được biến đổi dựa trên một số trường hợp kiểm thử gốc hay mô hình sinh trường hợp nào đó, hoặc được sinh ra hoàn toàn ngẫu nhiên. Đồng thời quá trình phát hiện lỗi, hành vi bất thường hay sập hệ thống trong quá trình kiểm thử cũng dễ dàng quan sát được từ phía công cụ. Hai điều trên cho phép các công cụ fuzzing (gọi tắt là fuzzer) có một lợi thể to lớn là có thể vận hành hoàn toàn tự động với độ chính xác khá cao, từ bước tạo trường hợp kiểm thử, đến việc đưa từng trường hợp vào các mục tiêu kiểm thử và sau cùng là tự động phát hiện hành vi bất thường ở phía phần mềm.\par
Tính hiệu quả và độ ``thông minh'' của một fuzzer chủ yếu thể hiện qua cách thức sinh trường hợp kiểm thử, và một phần nhỏ cách thức phát hiện bất thường trên phần mềm. Dựa vào cách thức sinh trường hợp kiểm thử, Harper và các cộng sự \parencite{harper2011gray} đã phân loại các fuzzer thành ba loại như sau.
\begin{itemize}
    \item \textbf{Fuzzer đột biến (mutation fuzzer)} là nhóm các công cụ sinh trường hợp kiểm thử ngẫu nhiên đơn giản nhất. Các trường hợp kiểm thử được sinh ra bằng cách thay đổi ít hoặc nhiều (đột biến) các trường hợp kiểm thử gốc theo một quy luật nào đó, thường là hoàn toàn ngẫu nhiên.
    \item \textbf{Fuzzer tự sinh (generation fuzzer)} còn được gọi là fuzzer hộp trắng. Cách tiếp cận này dựa vào sự am hiểu vào đối tượng kiểm thử của người phát triển công cụ. Các fuzzer tự sinh này không cần dựa trên các trường hợp kiểm thử mẫu như fuzzer đột biến, mà nó sẽ tự sinh ra trường hợp kiểm thử dựa trên các \textbf{mô hình dữ liệu} được định nghĩa trước. Các mô hình này thường được mô tả dưới dạng các tập tin cấu hình có cấu trúc tùy thuộc vào fuzzer sử dụng.
    \item \textbf{Fuzzer tiến hóa (evolutionary fuzzer)} có khả năng chọn ra một tập các trường hợp kiểm thử tốt nhất bằng cách tối ưu hóa mức độ che phủ mã nguồn (code coverage) của mục tiêu kiểm thử theo thời gian. Trong thực tế, công cụ sẽ chọn ra những cách thay đổi (mutate) trường hợp kiểm thử khiến nó chạm tới được những đoạn code sâu hơn trong chương trình hoặc gây lỗi khác với các trường hợp kiểm thử bình thường.
\end{itemize}
Trên thị trường hiện tại có nhiều fuzzer được thiết kế để sinh trường hợp kiểm thử hoặc thực hiện việc kiểm thử phần mềm nói chung và ứng dụng web nói riêng trên nhiều nền tảng, môi trường khác nhau. Theo kinh nghiệm của bản thân tôi, một trong những fuzzer tốt nhất hiện tại là Radamsa \parencite{radamsa-gitlab} được phát triển bởi Aki Helin. Công cụ này có khả năng sinh các trường hợp kiểm thử theo định nghĩa và mục đích của người dùng nên do đó, ta có thể áp dụng những trường hợp kiểm thử sinh được trong bất kì phần mềm nào nói chung và các ứng dụng web nói riêng.