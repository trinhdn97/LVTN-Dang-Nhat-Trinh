\section{Phương pháp kiểm thử xâm nhập}
Kiểm thử xâm nhập (penetration testing) \parencite{vimpari2015evaluation} là phương pháp kiểm tra bảo mật trong đó các kĩ sư cố gắng tìm ra, khai thác và đánh giá mức độ nghiêm trọng của các lỗ hổng bảo mật dựa trên những hiểu biết của họ về thiết kế lẫn đặc điểm hiện thực của một hệ thống ứng dụng cụ thể. Quy trình kiểm thử xâm nhập thường được tiến hành bởi đội đỏ (red team) của đội ngũ bảo mật của ứng dụng, hoặc bởi một tổ chức thứ ba chuyên về lĩnh vực này. Phương pháp này đặc biệt hiệu quả đối với các ứng dụng phức tạp gồm nhiều thành phần tổ hợp lại thành một hệ thông hoàn chỉnh như mô hình các ứng dụng web hiện nay. Đội ngũ kiểm thử sẽ xem xét toàn thể ứng dụng từ phía người dùng (client-side) và máy chủ (server-side), cố gắng can thiệp vào hoạt động của các thành phần nằm sâu trong back-end như các tập tin và tiến trình hệ thống, cơ sở dữ liệu, thậm chí cả việc kiểm thử bảo mật vật lý của hệ thống. Bằng cách tiến hành kiểm thử xâm nhập trong môi trường thực tế, đội ngũ bảo mật của hệ thống ứng dụng có thể vá lỗi và phòng chống những lỗ hổng bảo mật trong tương lai trước khi bị tin tặc khai thác.\par
Theo Weidman và Georgia \parencite{weidman2014penetration}, một cuộc kiểm thử xâm nhập hệ thống ứng dụng sẽ trải qua lần lượt các bước như sau.
\begin{enumerate}
    \item \textbf{Thỏa thuận tiến hành} là giai đoạn đầu tiên trong quá trình kiểm thử xâm nhập. Bên dịch vụ kiểm thử sẽ thống nhất với khách hàng về mục tiêu, phạm vi, cách xử lí một số trường hợp đặc thù, thông tin liên hệ cũng như chi phí phát sinh trong quá trình kiểm thử trước khi tiến hành.
    \item Tiếp theo là giai đoạn \textbf{thu thập thông tin}. Kĩ sư kiểm thử sẽ tận dụng những thông tin, công cụ sẵn có để tìm ra những cách tiềm năng để kết nối vào hệ thống mục tiêu.
    \item Sau đó, quá trình kiểm thử bước vào giai đoạn \textbf{mô hình hóa nguy cơ bảo mật}. Dựa vào những thông tin thu thập được ở bước trên, kĩ sư kiểm thử sẽ phát triển những chiến lược, phương pháp cụ thể dưới tâm thế tấn công vào hệ thống mục tiêu.
    \item Trước khi kĩ sư kiểm thử bắt đầu tấn công vào hệ thống, họ cần thực hiện quá trình \textbf{phân tích lỗ hổng}, tính toán khả năng thành công khi thực hiện một chiến lược tấn công nhất định. Một chiến lược tấn công sai lầm có thể làm gián đoạn hoạt động của một vài dịch vụ hoặc cả hệ thống, dẫn tới giảm tỉ lệ khai thác thành công lỗ hổng đã tìm thấy. Quá trình \textbf{khai thác} sẽ được tiến hành ngay sau đó.
    \item Sau khi \textbf{khai thác} thành công, kĩ sư kiểm thử đã xâm nhập được vào một phần của hệ thống mục tiêu. Họ tiếp tục tiến hành giai đoạn \textbf{hậu khai thác} để cố gắng leo thang đặc quyền vào các thành phần, cơ sở dữ liệu, trang web quan trọng hơn của hệ thống, khai phá những trường hợp xấu nhất có thể xảy ra sau khi xâm nhập thành công.
    \item Cuối cùng, họ sẽ \textbf{báo cáo kết quả} tổng quan và chi tiết với khách hàng và có thể đề xuất phương hướng khắc phục những lỗ hổng bảo mật đã tìm thấy trong quá trình kiểm thử.
\end{enumerate}
Như vậy, thông qua quá trình tìm hiểu khái niệm và cách thức tiến hành phương pháp kiểm thử xâm nhập ở trên, chúng tôi nhận thấy phương pháp này khó có thể được dùng để phát triển một công cụ kiểm thử tự động hoặc bán tự động được.
\section{Phương pháp fuzzing}
Fuzzing \parencite{klees2018evaluating} là một trong những phương pháp phổ biến nhất trong lĩnh vực kiểm thử bảo mật phần mềm nói chung và ứng dụng web nói riêng. Khái niệm fuzzing theo Bekrar, Bekrar, Groz và Mounier \parencite{vimpari2015evaluation} có nghĩa là đưa những dữ liệu đầu vào ngẫu nhiên hoặc không hợp lệ vào phần mềm để gây ra những hành vi bất thường, và xác định các lỗi cũng như khả năng tồn tại lỗ hổng bảo mật trong phần mềm. Mục đích của quan trọng nhất của fuzzing là gây lỗi hoặc làm sập (crash) hệ thống, mỗi một lỗi xuất hiện hoặc một lần hệ thống bị sập trong quá trình kiểm thủ là một dấu hiệu có lỗ hổng bảo mật tiềm ẩn. Sau đó những kĩ sư bảo mật sẽ phân tích các lỗi đó để tìm ra lý do và khai thác sâu hơn hoặc báo cáo lại với nhà cung cấp phần mềm (vendor) để vá lỗi.\par
Phương pháp fuzzing hữu dụng và phù hợp với việc kiểm thử hộp đen một phần vì tính tự động hóa cao của nó. Những mục tiêu kiểm thử trên phần mềm có thể là mọi ``giao diện'' có khả năng tương tác và nhận dữ liệu đầu vào từ người dùng. Mục tiêu kiểm thử của một phần mềm thường là những biến môi trường, nội dung và tên của những tập tin đang được sử dụng bởi phần mềm, những trường nhập dữ liệu, giao thức mà phần mềm dùng để giao tiếp với người dùng hoặc các phần mềm khác và các giao diện lập trình ứng dụng (application programming interface - API) được định nghĩa bởi phần mềm đó. Quá trình sinh ra trường hợp kiểm thử (testcase) cho các mục tiêu đó có thể được định nghĩa trước thành một danh sách, hoặc được biến đổi dựa trên một số trường hợp kiểm thử gốc hay mô hình sinh trường hợp nào đó, hoặc được sinh ra hoàn toàn ngẫu nhiên. Đồng thời quá trình phát hiện lỗi, hành vi bất thường hay sập hệ thống trong quá trình kiểm thử cũng dễ dàng quan sát được từ phía công cụ. Hai điều trên cho phép các công cụ fuzzing (gọi tắt là fuzzer) có một lợi thể to lớn là có thể vận hành hoàn toàn tự động với độ chính xác khá cao, từ bước tạo trường hợp kiểm thử, đến việc đưa từng trường hợp vào các mục tiêu kiểm thử và sau cùng là tự động phát hiện hành vi bất thường ở phía phần mềm.\par
Tính hiệu quả và độ ``thông minh'' của một fuzzer chủ yếu thể hiện qua cách thức sinh trường hợp kiểm thử, và một phần nhỏ cách thức phát hiện bất thường trên phần mềm. Dựa vào cách thức sinh trường hợp kiểm thử, Harper và các cộng sự \parencite{harper2011gray} đã phân loại các fuzzer thành ba loại như sau.
\begin{itemize}
    \item \textbf{Fuzzer đột biến (mutation fuzzer)} là nhóm các công cụ sinh trường hợp kiểm thử ngẫu nhiên đơn giản nhất. Các trường hợp kiểm thử được sinh ra bằng cách thay đổi ít hoặc nhiều (đột biến) các trường hợp kiểm thử gốc theo một quy luật nào đó, thường là hoàn toàn ngẫu nhiên.
    \item \textbf{Fuzzer tự sinh (generation fuzzer)} còn được gọi là fuzzer hộp trắng. Cách tiếp cận này dựa vào sự am hiểu vào đối tượng kiểm thử của người phát triển công cụ. Các fuzzer tự sinh này không cần dựa trên các trường hợp kiểm thử mẫu như fuzzer đột biến, mà nó sẽ tự sinh ra trường hợp kiểm thử dựa trên các \textbf{mô hình dữ liệu} được định nghĩa trước. Các mô hình này thường được mô tả dưới dạng các tập tin cấu hình có cấu trúc tùy thuộc vào fuzzer sử dụng.
    \item \textbf{Fuzzer tiến hóa (evolutionary fuzzer)} có khả năng chọn ra một tập các trường hợp kiểm thử tốt nhất bằng cách tối ưu hóa mức độ che phủ mã nguồn (code coverage) của mục tiêu kiểm thử theo thời gian. Trong thực tế, công cụ sẽ chọn ra những cách thay đổi (mutate) trường hợp kiểm thử khiến nó chạm tới được những đoạn code sâu hơn trong chương trình hoặc gây lỗi khác với các trường hợp kiểm thử bình thường.
\end{itemize}
Trên thị trường hiện tại có nhiều fuzzer được thiết kế để sinh trường hợp kiểm thử hoặc thực hiện việc kiểm thử phần mềm nói chung và ứng dụng web nói riêng trên nhiều nền tảng, môi trường khác nhau. Một trong những fuzzer tốt nhất hiện tại là Radamsa\footnotet{\href{https://gitlab.com/akihe/radamsa}{https://gitlab.com/akihe/radamsa}} được phát triển bởi Aki Helin. Công cụ này có khả năng sinh các trường hợp kiểm thử theo định nghĩa và mục đích của người dùng nên do đó, ta có thể áp dụng những trường hợp kiểm thử sinh được trong bất kì phần mềm nào nói chung và các ứng dụng web nói riêng. Ngoài ra còn có thể kể đến KameleonFuzz \parencite{KameleonFuzz}, một fuzzer tiến hóa được thiết kế để kiểm thử hộp đen lỗ hổng \acrshort{xss} (\acrlong{xss}) trên các ứng dụng web. Công cụ này không chỉ tự sinh trường hợp kiểm thử tốt hơn theo thời gian mà còn chỉ ra được trường hợp kiểm thử hiện tại đã gần khai thác được lỗ hổng đến mức nào. Phương pháp này fuzzing khá phù hợp để hiện thực một ứng dụng kiểm thử tự động hoặc bán tự động khi đã có sẵn đối tượng và trường hợp kiểm thử.