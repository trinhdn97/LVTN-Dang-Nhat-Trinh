\section{Giao diện người dùng}
Giao diện người dùng của ứng dụng webfuzzer được xây dựng dựa trên bản mẫu (template) React Reduction \parencite{react-reduction-github}. Bản mẫu này được viết trên React.js với sự hỗ trợ của thư viện reactstrap \parencite{reactstrap}, hiện thực sẵn một số thành phần như thanh điều hướng, các nút bấm, ô lựa chọn, bảng biểu, kiểu chữ,... cũng như giao diện mặc định đẹp mắt, dễ dàng chỉnh sửa theo nhu cầu lập trình. Công việc của chúng tôi là hiện thực và thiết lập luồng hoạt động của ba thành phần chính của \acrshort{ui}, đảm nhiệm được việc gọi các \acrshort{api} backend cung cấp và xử lí kết quả trả về, hiển thị được những thông tin cần thiết đồng thời đáp ứng nhu cầu kiểm thử của người dùng như yêu cầu và thiết kế \acrshort{ui} đã đề ra ở \textbf{Chương 5}.\par
React.js là một khung thức lập trình giao diện người dùng hướng thành phần (component-based), mỗi trang web và các thành phần nhỏ hơn trong trang đa phần đều kế thừa các class có sẵn của React.js và được hiện thực dưới dạng các component. Mỗi component có tập các trạng thái riêng (state) và tập những thuộc tính được truyền vào (props). Bản thân một component trong React.js sẽ chỉ thay đổi được state của nó bằng phương thức \texttt{setState} chứ không thay đổi được những props mà nó được nhận. Mỗi khi hàm \texttt{setState} thực hiện xong, phương thức \texttt{render} của component đó sẽ được khởi chạy, tải lại nội dung hiển thị của component theo những giá trị state mới mà không làm mới lại cả trang web. Phương thức \texttt{render} của các component trả về giá trị là các JSX, những đoạn mã \acrshort{html} lồng với JavaScript đặc trưng của khung thức này, thể hiện nội dung hiển thị của component ở giao diện người dùng.\par
Trước tiên, trong quá trình hiện thực \acrshort{ui} của ứng dụng, chúng tôi sử dụng thư viện Axios \parencite{axios-npm} để tương tác với các \acrshort{api} ở backend ứng dụng webfuzzer. Thư viện này hỗ trợ gửi và nhận các thông điệp \acrshort{http} một cách đơn giản thông qua việc cung cấp các tham số cần thiết như đường dẫn \acrshort{api}, phương thức \acrshort{http} kèm theo body và các tham số nếu có. Những lời gọi \acrshort{api} này nằm trong các đoạn mã xử lí sự kiện của JSX khi người dùng tương tác với giao diện và khi tải nội dung trang. Đoạn mã \ref{lst:call-API-from-UI} sau hiện thực việc gọi API và lấy ra kết quả trả về trong mã nguồn \acrshort{ui}.
\begin{lstlisting}[style=ES6, label={lst:call-API-from-UI}, caption={Gọi API từ mã nguồn UI}]
import axios from 'axios';
const BASE_URL = require('./globalConfig').BASE_URL;
const callApi = async (endpoint, method = 'get', body) => {
  try {
      let { data } = await axios({
        method: method,
        url: `${BASE_URL}${endpoint}`,
        data: body
      });
      return data;
  } catch (err) {
      console.log(err);
      return null;
  }
}
\end{lstlisting}
\subsection{Trang bảng điều khiển}
Đầu tiên khi tải trang web xuống, người dùng cần có sẵn danh sách các request mẫu và loại lỗ hổng cần kiểm thử để chọn tạo yêu cầu kiểm thử. Để làm được điều này, ta gọi các \acrshort{api} tương ứng trong phương thức \texttt{componentDidMount} của component, phương thức này luôn chạy đầu tiên mỗi khi component chứa nó được gọi đến. Đoạn mã \ref{lst:component-did-mount} sau là phương thức \texttt{componentDidMount} của component trang bảng điều khiển, lấy các danh sách cần thiết từ \acrshort{api} và lưu vào state của component này.
\begin{lstlisting}[style=ES6, label={lst:component-did-mount}, caption={Hiện thực các thành phần của trang bảng điều khiển}]
componentDidMount = async () => {
	let apiList = [this.getListEndpoints(), this.getVulneTypes()]
	let [res1, res2] = await Promise.all(apiList);
}
getListEndpoints = async (limit = 5, offset = 0) => {
  ...
  let endpointList = await callApi(endpoints.getAllEndpoinst(limit, offset), 'get', null);
  if (endpointList && endpointList.results) {
    let list = endpointList.results.endpointList;
    this.setState({
      endpointsList: list,
      totalRecord: endpointList.results.total
    });
    setTimeout(() => {
      this.setState({ loading: false })
    }, 1000);
  }
  ...
}
getVulneTypes = async () => {
  ...
  let { results } = await callApi(endpoints.getListVulnes, 'get', null);
  let arr = [];
  if (results) {
    Object.keys(results).forEach((key, idx) => {
      let vulne = {
        id: String(key),
        label: results[key].label,
        check: false,
        type: key === '6' ? 'common' : 'auto'
      }
      arr.push(vulne);
    })
  }
  this.setState({ vulneTypes: [...arr] });
  ...
}
\end{lstlisting}
Theo thiết kế giao diện đã đề ra ở \textbf{Chương 5}, trang này cần ba khung để hiển thị danh sách request mẫu, chi tiết request mẫu, khung chọn lỗ hổng cần kiểm thử và một nút nhấn để tạo yêu cầu kiểm thử. Phương thức \texttt{render} của component này căn chỉnh các khung vuông vức bằng các thành phần (component) \texttt{Row, Column} trong Layout của thư viện reactstrap cùng với \acrshort{css} như Đoạn mã \ref{lst:implement-dashboard-page} sau.
\begin{lstlisting}[style=ES6, label={lst:implement-dashboard-page}, caption={Phương thức \texttt{render} của trang bảng điều khiển}]
<Page
  className="DashboardPage"
  title="Dashboard"
>
  <Row>
    <Col lg="4">
      <EndpointsComponent
        endpointsList={this.state.endpointsList}
        selectEndpoint={this.selectEndpoint}
        enpointSelected={this.state.enpointSelected}
        getListEndpoints={this.getListEndpoints}
        loading={this.state.loading}
        totalRecord={this.state.totalRecord}
      />
    </Col>
    <Col lg="8">
      <BaseRequestComponent selectedEndpoint={this.state.enpointSelected} />
    </Col>
  </Row>
  <Row>
    <Col lg="4">
      <ListVulnes
        listVulnes={this.state.vulneTypes}
        selectVulne={this.selectVulne}
        checkedAllAutoFuzz={this.state.checkedAllAutoFuzz}
        toogleAllAutoFuzz={this.toogleAllAutoFuzz}
      />
      <div className="btn-submit">
        {this.state.loadingSubmit ?
          <AwaitingComponent /> :
          <button
            disabled={!this.state.enpointSelected.Id}
            onClick={() => this.submitFuzzRequest()}>Create fuzz request
        </button>}
      </div>
    </Col>
    <Col lg="8"></Col>
  </Row>
</Page>
\end{lstlisting}
Khung chứa danh sách request mẫu tương ứng với component \texttt{EndpointsComponent} và khung hiển thị nội dung request mẫu tương đương ứng component \texttt{BaseRequestComponent}. Mỗi thành phần này được đặt trong một \texttt{Col} riêng và cả hai nằm trong cùng một \texttt{Row} trong mã nguồn, nên chúng sẽ ngang hàng nhau trên trang web như Hình \ref{fig:dashboard-ui} sau.
\FloatBarrier
\begin{sidewaysfigure}[!htb]
    \centering
        \includegraphics[scale=0.45,keepaspectratio=true]{images/dashboard-ui.png}
    \caption{Giao diện trang bảng điều khiển ở UI ứng dụng webfuzzer}
    \label{fig:dashboard-ui}
\end{sidewaysfigure}
\FloatBarrier
Tương tự, khung chọn loại lỗ hổng kiểm thử tương ứng với component \texttt{ListVulnes} và nút tạo yêu cầu kiểm thử ứng với thẻ \texttt{<div className="btn-submit">} trong mã nguồn. Hàm xử lí sự kiện \texttt{onClick} nhấn nút này là hàm \texttt{this.submitFuzzRequest()} có chức năng gọi đến \acrshort{api} \colorbox{gray!30}{\texttt{POST /target}} để tạo yêu cầu kiểm thử dựa trên request mẫu và những loại lỗ hổng đã chọn. 
\subsection{Trang kết quả kiểm thử}
\FloatBarrier
\begin{sidewaysfigure}[!htb]
    \centering
        \includegraphics[scale=0.44,keepaspectratio=true]{images/result-ui.png}
    \caption{Giao diện trang kết quả kiểm thử ở UI ứng dụng webfuzzer}
    \label{fig:result-ui-ui}
\end{sidewaysfigure}
\FloatBarrier
\subsection{Thanh điều hướng và các thành phần khác}
\begin{figure}[H]
  \centering
    \includegraphics[width=0.9\textwidth,keepaspectratio=true]{images/notification-example.png}
  \caption{Thanh điều hướng và ví dụ thông báo đấy trên giao diện người dùng}
  \label{fig:notification-example}
\end{figure}

\section{Cơ sở dữ liệu}
Dựa vào thiết kế đã đề ra ở \textbf{Chương 5}, chúng tôi hiện thực cấu trúc cơ sở dữ liệu của ứng dụng webfuzzer gồm ba bảng chính. Bảng \ref{tab:db-tables} dưới đây mô tả tên và chức năng của từng bảng trong lược đồ.
\begin{table}[ht]
    \centering
    \caption{Các bảng trong lược đồ quan hệ}
    \label{tab:db-tables}
    \begin{tabular}[ht]{lll}
        \toprule[1pt]\midrule[0.3pt]
            \textbf{Tên}& &\textbf{Mô tả}\\ 
        \midrule
            Endpoint& &Bảng Endpoint lưu lại các request mẫu mục tiêu được\\
            {}& &gửi đến máy chủ từ phần mở rộng Burp Suite\\
            \addlinespace
            Request& &Bảng Request lưu những yêu cầu kiểm thử một request mẫu \\
            {}& &trong bảng Endpoint của người dùng\\
            \addlinespace
            Result& &Bảng Result lưu kết quả kiểm thử chi tiết ứng với\\
            {}& &mỗi yêu cầu kiểm thử trong bảng Request\\
            \addlinespace
        \midrule[0.3pt]\bottomrule[1pt]
    \end{tabular}
\end{table}
\FloatBarrier
Hình \ref{fig:db-schema} dưới đây mô tả quan hệ giữa các bảng trong lược đồ.
\begin{figure}[H]
  \centering
    \includegraphics[width=0.75\textwidth,keepaspectratio=true]{images/database-design.png}
  \caption{Sơ đồ mối quan hệ giữa các bảng trong lược đồ}
  \label{fig:db-schema}
\end{figure}
Bảng \texttt{Endpoint} lưu trữ \acrshort{http} request mẫu được gửi từ phần mở rộng Burp Suite đến backend thông qua API \colorbox{gray!30}{\texttt{POST /}}. Request mẫu đó chứa dưới dạng chuỗi dữ liệu JSON trong trường \texttt{BaseRequest}. Trường \texttt{Url} chứa riêng \acrshort{url} của điểm cuối ứng dụng web mục tiêu để thuận lợi trong việc lọc ra những yêu cầu kiểm thử của cùng một trang web thông qua API \colorbox{gray!30}{\texttt{POST /target/search}}. Trường \texttt{Hash} chứa giá trị băm của chuỗi \texttt{BaseRequest}, đảm bảo không lưu hai request mẫu y hệt nhau gây dư thừa dữ liệu. Bảng \texttt{Request} chứa thông tin của các yêu cầu kiểm thử, trong đó trường \texttt{IdEndpoint} là khoá ngoại tham chiếu tới khoá chính \texttt{Id} của bảng \texttt{Endpoint} và trường \texttt{IdResult} là khoá ngoại tham chiếu tới khoá chính \texttt{Id} của bảng \texttt{Result} chứa kết quả kiểm thử (trong trường hợp có lỗ hổng). Mỗi bản ghi trong bảng \texttt{Request} chứa \acrshort{http} request mẫu gửi đến các điểm cuối của ứng dụng web mục tiêu, tập các lỗ hổng cần kiểm thử, trạng thái, và kết quả kiểm thử tương ứng, bao gồm danh sách lỗ hổng của điểm cuối đó và các payload phát hiện được. Trường \texttt{BaseRequest} của bảng \texttt{Endpoint}, trường \texttt{VulnTypes} của bảng \texttt{Request} và \texttt{Result} của bảng \texttt{Result} là các trường có kiểu chuỗi, chứa các giá trị kiểu đối tượng JSON đã được chuỗi hóa như đã đề cập trong phần thiết kế kiến trúc cơ sở dữ liệu ở trên.